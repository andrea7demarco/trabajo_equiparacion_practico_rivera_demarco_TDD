# Conclusiones individuales

## Tomas 

La experiencia práctica de aplicar TDD en este proyecto me permitió conocer varios aspectos sobre esta metodología. 

Sobre sus desafíos, en primer lugar noté la dificultad real de evitar la sobre-ingeniería: al principio me parecía algo fácil, sin embargo lo es cuando uno piensa en una feature extra o algún módulo no planeado desde el comienzo, pero no es tan fácil de evitar cuando se trata de un solo atributo que genera una relación entre clases que podría ser innecesaria, o un pequeño condicional que crees necesario y se te ocurre mientras implementas lógica para un test… Si bien TDD promueve implementar únicamente lo necesario para satisfacer una prueba, en la práctica no siempre resulta claro en qué punto el diseño comienza a adelantarse a necesidades futuras. 

Otra fricción que encontré aplicando la metodología, fue que la literatura consultada no brinda lineamientos suficientemente concretos sobre cómo aplicar TDD en sistemas orientados a objetos, lo que genera incertidumbre al principio pues no uno no sabe de dónde partir, y te planteas desde qué clase arrancar la lógica, o hasta cómo debería llamarse ese objeto.

Este segundo problema mencionado se acentúa en contextos colaborativos, es más, fue un problema en este simple proyecto de 2 colaboradores. Como el diseño emerge del código y no existe una estructura inicial consensuada, es frecuente que distintos miembros del equipo creen clases con responsabilidades similares pero con nombres o enfoques distintos, lo que deriva en conflictos en el control de versione, e implica mayor inversión de tiempo en la resolución de los mismos, renombrando clases, métodos, ajustando atributos en objetos, sus propiedades, etc…

A esto se suma la dificultad para delimitar claramente las iteraciones del ciclo Red–Green–Refactor: en muchos casos surgen ajustes incrementales sobre pruebas existentes que no permiten distinguir con claridad si se trata de una nueva iteración o de un refinamiento, generando nuevamente dudas sobre posibles situaciones de sobre-ingeniería.

Por otro lado, personalmente, el impacto positivo de TDD en el diseño de clases y sus responsabilidades no me pareció tan determinante como se plantea teóricamente. Si bien la metodología favorece el desacoplamiento de la lógica de negocio del I/O y evitar relaciones complejas entre objetos, las decisiones de diseño más estructurales —como la introducción de servicios o repositorios— terminan dependiendo en gran medida de la experiencia previa del desarrollador, y probablemente hubieran sido adoptadas incluso sin el uso de TDD. Esto  sucedió en esta pequeña aplicación desarrollada bajo el patrón MVC, habría que ver si este problema se replica a gran escala en arquitecturas más complejas (aunque quizá estoy contradiciendo los principios de la metodología pensando en una arquitectura antes de dejar que derive del código, pero espero se entienda el punto).

No obstante, la metodología presenta ventajas claras y concretas. En particular, me resulta especialmente útil para evitar la típica parálisis por análisis y simplemente empezar con el desarrollo del producto. Este punto es muy favorable en casos donde un equipo se propone lanzar un MVP y la prioridad es obtener software funcional de manera temprana —punto que a su vez, se alinea con las metodologías ágiles, y de aquí entiendo por qué suelen combinarse—. Además, su naturaleza incremental favorece la comunicación con el cliente, pienso que si se lo combina de alguna manera con un trabajo paralelo en la interfaz de usuario, permitiría comunicar muy rápidamente nuevas funcionalidades.

Un aspecto destacado de esta experiencia fue el rol de la inteligencia artificial como apoyo en la generación de casos de prueba. La posibilidad de obtener sugerencias sobre edge cases y corner cases facilitó la aplicación de TDD, reduciendo una de las principales barreras de entrada para desarrolladores con menor experiencia en testing —aspecto negativo que algunos autores mencionan—. 

Finalmente, es muy genuino que el uso de pruebas automatizadas como mecanismo de regresión genera un alto nivel de confianza al momento de refactorizar, permitiendo detectar errores de forma inmediata y garantizar que el comportamiento del sistema se mantuviera correcto durante todo el proceso de evolución del código.

## Andrea

Desde mi experiencia personal, la aplicación de TDD durante el desarrollo del proyecto resultó positiva, aunque no estuvo exenta de dificultades. Uno de los principales aspectos negativos observados fue la posibilidad de incurrir en sobre-ingeniería al momento de escribir los tests, ya sea implementando más lógica de la necesaria o, en el extremo opuesto, quedándose en soluciones demasiado básicas que luego requieren múltiples refactorizaciones. En este sentido, si bien no siempre se realizan numerosos ciclos completos de Red–Green, sí se presentan iteraciones frecuentes en la etapa de refactorización, lo cual puede generar cierta confusión respecto del avance real del desarrollo.

Otra dificultad surgió del trabajo en equipo. Aunque el proyecto fue desarrollado por dos personas, al trabajar en ramas separadas y abordar distintos casos de uso, al momento de realizar los merge aparecieron conflictos relacionados con la nomenclatura de clases, métodos y estructuras generales. En nuestro caso, estos conflictos se resolvieron mediante instancias de pair programming, que permitieron consensuar nombres y responsabilidades. Sin embargo, no resulta evidente cómo este enfoque podría escalar a equipos más numerosos o a proyectos de mayor complejidad.

Por otro lado, la metodología presentó ventajas significativas. En particular, TDD permitió cubrir una amplia variedad de escenarios de error, ya que el desarrollo comienza a partir de una implementación mínima que luego se va enriqueciendo progresivamente. Este enfoque facilita la detección temprana de fallos y promueve una evolución controlada del código.

Asimismo, uno de los beneficios más destacados fue que nunca se incorpora código que no funcione correctamente. Al existir pruebas previas que definen el comportamiento esperado, los errores de lógica se detectan de manera casi inmediata, incluso antes de ejecutar la aplicación. Esto reduce considerablemente el tiempo invertido en pruebas manuales y en la ejecución repetida del sistema para verificar su funcionamiento.

Finalmente, el uso de pruebas automatizadas generó una mayor sensación de confianza al momento de agregar o modificar funcionalidades. La posibilidad de validar rápidamente los cambios realizados permitió avanzar de forma más segura y continua. En este contexto, la incorporación de inteligencia artificial como apoyo resultó especialmente valiosa, ya que facilitó la generación de casos de prueba más completos y ayudó a reducir la incertidumbre inicial asociada a la escritura de buenos tests, especialmente para desarrolladores con poca experiencia previa en testing.

# Conclusión general

La experiencia con TDD demostró que la metodología resulta especialmente útil para detectar errores de forma temprana, facilitar la refactorización y brindar mayor confianza durante el desarrollo. Sin embargo, también presentó limitaciones vinculadas a la sobre-ingeniería, la ambigüedad en el diseño orientado a objetos y la coordinación en equipos colaborativos. En función de lo observado, TDD sería una metodología recomendable para proyectos desarrollados por equipos reducidos (cinco personas o menos) y para productos que requieran salir rápidamente al mercado, donde su naturaleza incremental, ahorro de tiempo en debugging y testng, y la validación temprana del comportamiento resultan prioritarios.
